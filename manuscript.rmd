---
bibliography: manuscript.bib
csl: nature.csl
output:
  github_document: default
  pdf_document:
    dev: png
---

```{r setup, cache=TRUE, message=F, echo=FALSE, warning=F}

	knitr::opts_chunk$set( echo = TRUE )

```

```{r preliminaries, echo=FALSE, message=F, warning=F}
	library( treeio )
	library( tidyverse )
	library( magrittr )
	library( stringr )
	library( parallel )
	library( ggtree )
	library( ape )
	library( digest )
	library( hutan )  # From https://github.com/caseywdunn/hutan
	library( gridExtra )
	library( geiger )
	library( phytools )

	# Set system computational parameters
	cores = detectCores() - 1
	if ( cores < 1 ) {
		cores = 1
	}
	set.seed( 23456 )
	
	# Name of the compara gene trees file. This is from 
	# ftp://ftp.ensembl.org/pub/release-75/emf/ensembl-compara/homologies/
	# but not included here due to its size. Put it in the kmrr/ directory
	gene_tree_name = "Compara.75.protein.nhx.emf"
	
	# Files produced by KMRR Rscript.R with Tau values and other expression statistics
	expression_file_names = c(
		"ChickenBrawandTScomparisonTable_9_6chPC.txt", 
		"ChimpBrawandTScomparisonTable_9_6cmPC.txt", 
		"GorillaBrawandTScomparisonTable_9_6gPC.txt", 
		"HumBrawandTScomparisonTable_9_6hPC.txt", 
		"MacacaBrawandTScomparisonTable_9_6mcPC.txt", 
		"MusBrawandTScomparisonTable_9_6mPC.txt", 
		"OpossumBrawandTScomparisonTable_9_6oPC.txt", 
		"PlatypusBrawandTScomparisonTable_9_6pPC.txt"
	)
	
	kmrr_directory = "kmrr/"
	expression_file_names %<>% paste( kmrr_directory, ., sep="" )
	gene_tree_name %<>% paste( kmrr_directory, ., sep="" )
	
	# The minimum number of genes with expression data that a gene needs to have to be considered
	min_genes_with_expression = 4
	

	# These clade dates are from the KMRR code, they got them from http://timetree.org/
	calibration_times = data.frame(
        age =
            c( 20, 92, 167, 9, 42, 74, 296, 535, 104, 937, 29, 722, 441, 65, 15, 1215, 
                414, 371, 162, 25, 74, 77, 86, 7 ), 
        clade = 
            c("Hominoidea", "Euarchontoglires", "Mammalia", "Homininae", 
                    "Simiiformes", "Primates", "Amniota", "Vertebrata", "Eutheria", 
                    "Bilateria", "Catarrhini", "Chordata", "Euteleostomi", 
                    "Haplorrhini", "Hominidae", "Opisthokonta", "Sarcopterygii", 
                    "Tetrapoda", "Theria", "Murinae", "Sciurognathi", "Rodentia", "Glires", "Hominini"
            ),
        stringsAsFactors=FALSE
    )
	
	# The calibration times used for speciation nodes
	focal_calibrations_clades = 
		c( "Hominini", "Homininae", "Catarrhini", "Euarchontoglires", "Theria", "Mammalia", "Amniota" )
	
	
	# In simulation, the fold change in rate following duplication relative to speciation
	dup_adjust = 5
	
```

```{r define_functions, echo=FALSE, message=F, warning=F}
	
	#' Adds some random noise from a normal distribution to calibration
	#' times
	#' 
	#' @param calibration_times A dataframe with two columns: age.min is the age 
	#' of a clade, and clade is the name of the clade
	#' @param sd_fraction this is multiplied by each value to set sd of that value 
	#' @return A dataframe as above, but with noise
	#' @export
	add_noise_calibration_times = function( calibration_times, sd_fraction ) {
		age = calibration_times$age
		new_age = NA
		
		# Keep trying until dates are coherent with tree structure
		# This is a ladder tree, so that means checking that they 
		# are still in ascending order
		while( NA %in% new_age ) {
			x = sapply( 
				age,
				function( i ){
					rnorm( 1, mean = i, sd = ( sd_fraction * i ) )
				}
			)
			
			if( ( ! is.unsorted( x ) ) & all( x > 0 ) ){
				new_age = x
			}
			
		}
		
		calibration_times$age = new_age
		return( calibration_times )
	}	


	#' Get a boolean vector corresponding to all tips and internal nodes of 
	#' a tree, with value TRUE for tips and FALSE for internal nodes
	#' 
	#' @param nhx A phylogenetic tree as a treeio::treedata object
	#' @return A boolean vector
	#' @export
	is.tip.nhx = function( nhx ) {
		is.tip = rep( FALSE, nrow( nhx@data ) )
		is.tip[ 1:length( nhx@phylo$tip.label ) ] = TRUE
		is.tip
	}
	

	#' Fix ensembl clade names.
	#' Homininae is pan + homo + gorilla
	#' Hominini is pan + homo
	#' ENSEMBL Compara trees lislabel Hominini as Homininae
	#' 
	#' @param nhx A phylogenetic tree as a treeio::treedata object
	#' @return A phylogenetic tree as a treeio::treedata object
	#' @export
	fix_hominini = function( nhx ) {
		# Get the numbers for all nodes labeled as homininae
		homininae_nodes = nhx@data$node[ nhx@data$label == "Homininae" ]
		
		# Check which have no gorilla as a descendent
		no_gorilla = sapply(
			homininae_nodes,
			function( x ){
				tips = hutan::tip_descendants( nhx@phylo, x )
				tip_species = nhx@data$species[ tips ]
				return( ! "gorilla_gorilla" %in% tip_species )
			}
		)
		
		if( any( no_gorilla ) ){
			hominini_nodes = homininae_nodes[ no_gorilla ]
			nhx@data$label[ hominini_nodes ] = "Hominini"
		}
		
		return( nhx )
	}


	#' Record the distance from a tip for each node in a tree in 
	#' the data slot
	#' 
	#' @param nhx A phylogenetic tree as a  treeio::treedata
	#' @return A treeio::treedata object, with an additional node_age column
	#' in the data slot, or the original object if it was not of class treedata
	#' @export
	store_node_age = function( nhx ) {

		if ( class( nhx ) != "treedata" ) {
			return( nhx )
		}
		
		node_age = hutan::distance_from_tip( nhx@phylo )
		
		# make sure the dataframe is ordered by consecutive nodes
		stopifnot( all( nhx@data$node == 1:length( nhx@data$node ) ) )
		
		nhx@data$node_age = node_age 
		
		return( nhx )
	}
	
	#' Get the number of speciation events in an nhx tree
	#' 
	#' @param nhx A phylogenetic tree as a treeio::treedata object, with a 
	#' column @data$D that has value N for speciation events
	#' @return An integer indicating the number of speciation events
	#' @export
	get_n_speciation = function( nhx ){
		sum( nhx@data$D[ ! is.tip.nhx( nhx ) ] == "N", na.rm = TRUE )
	}
	
	#' Drop tips without expression data from a tree. 
	#' 
	#' @param nhx A phylogenetic tree as a treeio::treedata object, with a 
	#' column @data$Tau containing expression data
	#' @param min_genes_with_expression The minimum number of tips with 
	#' expression data for a tree to be retained
	#' @return A treeio::treedata object, or NA if less than 
	#' min_genes_with_expression
	#' @export
	drop_empty_tips = function( nhx, min_genes_with_expression ) {
		
		# Identify the tips without expression data
		to_drop = which( is.na( nhx@data[ 1:length( nhx@phylo$tip.label ), ]$Tau ) )
		
		# Return the pruned tree if it meets sampling criteria, otherwise return NA
		remaining = length( nhx@phylo$tip.label ) - length( to_drop )
		if( remaining >= min_genes_with_expression ){
			pruned = treeio::drop.tip( nhx, to_drop )
			return( pruned )
		}
		else{
			return( NA )
		}
	}


	#' Adjust branch lengths of a phylogenetic tree to make it ultrametric and 
	#' to time calibrate the speciation nodes to fixed values
	#' 
	#' @param nhx A phylogenetic tree as a treeio::treedata object, with speciation 
	#' nodes annotated with a value of "N" in @data$D
	#' @param calibration_times A dataframe with two columns: age is the age 
	#' of a clade, and clade is the name of the clade
	#' @param ... Any additional arguments to pass to ape::chronos()
	#' @return A treeio::treedata object if successfully calibrated
	#' @export
	calibrate_tree = function ( nhx, calibration_times, ... ) {
			
		# Create calibration matrix for speciation nodes
		calibration = 
			nhx@data[ !is.tip.nhx( nhx ), ] %>%
			filter( D == "N" ) %>%
			left_join( calibration_times, c( "label" = "clade" ) ) %>%
			mutate( age.min = age ) %>%
			mutate( age.max = age ) %>% 
			select( node, age.min, age.max ) %>%
			mutate( soft.bounds = NA )
		
		tree = try( 
			ape::chronos( nhx@phylo, calibration=calibration, ... ) 
		)

		if( "phylo" %in% class( tree ) ){
			class( tree ) = "phylo"
			nhx@phylo = tree
			return( nhx )
		}
		else{
			return( NA )
		}
	}
	
	#' Calculate phylogenetic independent contrasts (PIC) with the tree and 
	#' character data in a treeio::treedata object
	#' 
	#' @param nhx A phylogenetic tree as a treeio::treedata object, with a 
	#' column @data$Tau containing expression data
	#' @return A treeio::treedata object, with new @data columns pic and var_exp
	#' @export
	pic.nhx = function( nhx ) {
		
		tau = nhx@data$Tau[ is.tip.nhx( nhx ) ]
		
		if( any( is.na(tau) ) ){
			stop( "A trait value is NA." )
		}
		
		# Calculate the contrasts
		p = pic( tau, nhx@phylo, var.contrasts=TRUE )
	
		# Add the results back to the @data slot, padding the rows that correspond to 
		# tips with NA
		nhx@data$pic = c( rep( NA, length( nhx@phylo$tip.label ) ), p[ ,1 ] )
		nhx@data$var_exp = c( rep( NA, length( nhx@phylo$tip.label ) ), p[ ,2 ] )
	
		return( nhx )
	}

	#' Add phylogenetic independent contrasts (PIC) with the tree and 
	#' character data in a treeio::treedata object
	#' 
	#' @param gene_trees_calibrated A list of time calibrated phylogenetic trees 
	#' as treeio::treedata objects 
	#' @return A list of time phylogenetic trees with pics 
	#' as treeio::treedata objects
	#' @export
	add_pics_to_trees = function( gene_trees_calibrated ) {
	
		# Calculate independent contrasts for Tau on each tree, storing the results 
		# back into the @data slot of the tree objects
		gene_trees_pic = mclapply( gene_trees_calibrated, pic.nhx, mc.cores=cores )
		
		return( gene_trees_pic )
	}


	#' Add phylogenetic independent contrasts (PIC) with the tree and 
	#' character data in a treeio::treedata object
	#' 
	#' @param gene_trees_pic A list of phylogenetic trees with pics
	#' as treeio::treedata objects 
	#' @return A tibble with combined data, including phylogenetic independent 
	#' contrasts, for internal nodes of all trees
	#' @export
	summarize_contrasts = function( gene_trees_pic ) {
		# Combine the @data slots across all trees. These have labels, node annotations,
		# expression data, contrast results, etc...
		# Also take the absolute value of the contrast, since we only consider magnitude.
		nodes_all = 
			lapply( 
				gene_trees_pic, 
				function( nhx ){
					tags = nhx@data
					tags$gene = digest( nhx ) # Creates a  hash that is unique to each gene tree
					tags %<>% select( -( B ) ) # B has inconsistent types, remove it
					return( tags )
				}
			) %>%
			bind_rows() %>%
			mutate( pic = abs( pic ) )
		
		# Create a subset that corresponds to nodes with contrasts. This excludes tips.
		nodes_contrast = 
			nodes_all %>%
			filter( ! is.na( pic ) ) %>%
			filter( ! is.na( D ) )
		
		return( nodes_contrast )
	}


	#' Calibrate a list of gene trees given a set of speciation node dates
	#' 
	#' @param gene_trees_pruned A list of phylogenetic trees as treeio::treedata objects 
	#' with associated character data
	#' @param calibration_times A dataframe with two columns: age.min is the age 
	#' of a clade, and clade is the name of the clade
	#' @param ... Any additional arguments to pass to ape::chronos()
	#' @return A list of calibrated phylogenetic trees as treeio::treedata objects. May be 
	#' shorter than gene_trees_pruned if some calibrations fail.
	#' @export
	calibrate_trees = function( gene_trees_pruned, calibration_times, ... ) {
		# Make the trees ultrametric and calibrate the speciation nodes to 
		# specified times
		gene_trees_calibrated = 
			mclapply( 
				gene_trees_pruned,
				calibrate_tree, 
				calibration_times=calibration_times,
				...,
				mc.cores=cores
			)
		
		# Remove trees that could not be successfully calibrated
		gene_trees_calibrated = gene_trees_calibrated[ ! is.na( gene_trees_calibrated ) ]
		
		# Parse the calibrated node ages from the internal @phylo object and store them with the 
		# corresponding rows in the @data object
		gene_trees_calibrated = 
			mclapply( 
				gene_trees_calibrated, 
				store_node_age, 
				mc.cores=cores 
			)
		
		return( gene_trees_calibrated )
	}


	#' Wilcoxon test of the ortholog conjecture, specifically that contrasts
	#' associated with duplication nodes are greater than those for 
	#' speciation nodes. A significant result indicates rejection of the null
	#' hypothesis that they are not greater.
	#' 
	#' @param nodes_contrast A tibble of independent contrasts
	#' @return Wilcoxon test p value
	#' @export
	wilcox_oc = function( nodes_contrast ) {
 
		p = wilcox.test( 
			nodes_contrast %>% filter( D=="Y" ) %>% .$pic, 
			nodes_contrast %>% filter( D=="N" ) %>% .$pic, 
			alternative="greater" 
		)$p.value
		
		return( p )
	}

	#' Simulate Tau on a tree::treedata. Existing observed values are
	#' fit to a brownian model to estimate parameters. These parameters
	#' are then used to replace the original values with similated 
	#' values.
	#' 
	#' @param nhx A phylogenetic tree and associated Tau values 
	#' as a treeio::treedata object
	#' @param dup_adjust A multiplier for adjusting the branch lengths 
	#' following duplication to effectively change the rate following duplication
	#' @return A phylogenetic trees and simulated Tau values as a 
	#' treeio::treedata object
	#' @export
	sim_tau = function( nhx, dup_adjust=1 ) {
		
		phy = nhx@phylo
		
		# Estimate parameters
		tau_original = nhx@data$Tau [ 1:length( phy$tip.label ) ]
		names( tau_original ) = phy$tip.label
		brownian_model = fitContinuous( phy, tau_original )

		# Adjust length of branches that descend from duplication events. 
		# This is how we implement heterogeneous rates after duplication 
		# rather than speciation. Extending the branch lengths is equivalent 
		# to using a higher rate along them.
		dup_nodes = nhx@data$node[ nhx@data$D == "Y" ]
		dup_edges = phy$edge[,1] %in% dup_nodes
		phy$edge.length[ dup_edges ] = phy$edge.length[ dup_edges ] * dup_adjust

		# Simulate trait given the tree and parameter estimates
		x = fastBM( 
				phy, 
				a=brownian_model$opt$z0, 
				sig2=brownian_model$opt$sigsq, 
				bounds=c(-Inf,Inf) 
			) %>% abs()
		
		# Adjust the results so they fall between 0 and 1
		x[ x > 1 ] = 1
		x[ is.nan( x ) ] = 1
		
		
		names( x ) = NULL
		nhx@data$Tau = c( x, rep( NA, nrow( nhx@data ) - length (x ) ) )
		return( nhx )
	}


	#' Simulate a set of pics from a gamma distribution
	#' 
	#' @param scale Gamma scale parameter
	#' @param n Number of observations per event type	
	#' @return A dataframe
	#' @export
	sim_expectation = function( scale = 1, n = 10000 ){
		expectation = 
			bind_rows(
				data.frame( 
					pic = rgamma( n, 1, scale = scale ),
					Event = "Duplication",
					stringsAsFactors = FALSE
				),
				data.frame( 
					pic = rgamma( n, 1, scale = 1 ),
					Event = "Speciation",
					stringsAsFactors = FALSE
				)
			)
	
		event_levels = c( "Speciation", "Duplication" )
		expectation$Event = 
			factor( expectation$Event, levels=event_levels )
	
		return( expectation )
	}

```

# Multiple pairwise comparisons between species strongly mislead functional genomics studies

Casey W. Dunn^1^*, Felipe Zapata^1,2^, Catriona Munro^1^, Stefan Siebert^1,3^, Andreas Hejnol^4^

^1^ Department of Ecology and Evolutionary Biology, Brown University, Providence, RI, USA

^2^ Current address: Department of Ecology and Evolutionary Biology, University of California Los Angeles, Los Angeles, CA, USA

^3^ Current address: Department of Molecular & Cellular Biology, University of California at Davis, Davis, CA, USA

^4^ Sars International Centre for Marine Molecular Biology, University of Bergen, Bergen, Norway


\* Corresponding author, casey_dunn@brown.edu


## Abstract

There is now considerable interest in comparing functional genomics data across species, with the hope of providing an integrated understanding of genome and phenotype evolution. Most such studies have relied on multiple pairwise comparisons between species, an approach that does not incoporate information about the evolutionary relationships among species. This has the potential to mislead conclusions about the evolution of genome function, and is a missed opportunity to learn about biology that can only be understood in an explicit phylogenetic context. Here we examine two recently published studies that compare expression across species with pairwise methods.  We find problems with both that call their conclusions into question. One study interpreted higher expression correlation between orthologs than paralogs as evidence of the ortholog conjecture, *i.e.* the hypothesis that gene function evolution is more rapid after duplication than speciation. Instead, we find that this pattern is due to the structure of the gene phylogenies, not different rates of expression evolution, and is the expected pattern when rates are the same following duplication and speciation. The second study interpreted pairwise comparisons of embryonic gene expression across distantly related animals as evidence for a distinct evolutionary process that gave rise to animal phyla. Instead, we find that the pattern they identified is due to unique feature of a single species that impact multiple pairwise comparisons that include that species. In each study, distinct patterns of pairwise similarity among species were interpreted as evidence of particular evolutionary processes, but instead reflect the structure of the phylogenetic trees themselves. These reanalyses concretely demonstrate the inadequacy of pairwise comparisons for analyzing functional genomic data across species, and indicate that it will be critical to adopt phylogenetic comparative methods in future work. Fortunately, phylogenetic comparative biology is also a rapidly advancing field with many methods that can be directly applied to functional genomic data.


## Introduction

The focus of genomics research has quickly shifted from describing genome sequences to functional genomics, the study of how genomes "work" using tools that measure functional attributes such as expression, chromatin state, and transcription initiation. Functional genomics, in turn, is now becoming more comparative-- there is great interest in understanding how functional genomic variation across species gives rise to a diversity of development, morphology, physiology, and other phenotypes [@Wray:2013gh]. These analyses are also critical to transferring functional insight across species, and will grow in importance in coming years.

A rich theoretical and statistical methodology of phylogenetic comparative methods have been developed over the last three decades to address the challenges and opportunities of comparisons across species [@Felsenstein:1985ua; @Grafen:1989um; @Pagel:1999gc; Revell:2012jd; @FitzJohn:2012ey; @Uyeda:2014jl; @Garamszegi:2014ew]. A central challenge is the dependence of observations across species due to the evolutionary history of species -- more closely related species share many traits that evolve once in a common ancestor. This violates the fundamental assumption of independence of observations in standard statistical methods. Phylogenetic comparative methods have largely been applied to the evolution of morphological and ecological traits, but are just as relevant to functional genomics. Most Comparative Functional Genomics (CFG) studies have abstained from phylogenetic approaches and instead rely on multiple pairwise comparisons (Fig. 1A). These do not account for the fact that evolutionary relationships are expected to explain much of the structure of variation across species. This leaves CFG studies susceptible to statistical problems and is a missed opportunity to ask questions that are only accessible in an explicit phylogenetic context.

Phylogenetic comparative methods explicitly model trait change along the branches of evolutionary trees. The value of these methods relative to to pairwise comparisons has been repeatedly shown in analyses of other types of character data [@Ricklefs:1996wb; @Chamberlain:2012vx; @OMeara:2012gq]. One reason that CFG has not yet embraced phylogenetic approaches is that it has not yet been concretely demonstrated that pairwise and phylogenetic comparative methods can lead to different results when considering functional genomics data. Here we examine this issue be re-evaluating the pairwise comparisons used in two recent studies that compared gene expression across species.

The first study, Kryuchkova-Mostacci and Robinson-Rechavi (KMRR) 2016 [@KryuchkovaMostacci:2016iw], analyzed multiple vertebrate expression datasets to test the ortholog conjecture - the hypothesis that orthologs tend to have more conserved attributes (specificity of expression across organs in this case) than do paralogs [@Nehrt:2011bm, @Koonin:2005fp]. Using pairwise comparisons (Fig. 1A), they found lower expression correlation between paralogs than between orthologs and interpreted this as strong support for the ortholog conjecture. 

The second CFG study we evaluate here is Levin *et al.* [@Levin:2016bp]. This study analyzed gene expression through the course of embryonic development for ten animal species, each from a different phylum. Using pairwise comparisons (Figure 1A), they found there is more evolutionary variance in gene expression at a mid phase of development than there is at early and late phases for these ten animals (Fig. XX). They suggest that this supports an "inverse hourglass" model for the evolution of gene expression, in contrast with the "hourglass" model previously proposed for closely related species [@Kalinka:2010dw], and provides biological justification for the concept of phyla. We previously described concerns with the interpretations of this result [@Hejnol:2016hw]. Here we directly address the analyses themselves by examining the structure of the pairwise comparisons.

![Figure Overview](Figure_overview.png?raw=true)

> Figure 1 | Pairwise and phylogenetic comparative approaches. (a) Many comparative functional genomic studies rely on pairwise comparisons, where traits of each gene are compared to traits of other genes (such as orthologs and paralogs). This leads to many more comparisons than unique observations, making each comparison dependent on others. (b) Comparative phylogenetic methods, including phylogenetic independent contrasts [@Felsenstein:1985ua], make a smaller number of independent comparisons, where each contrast measures independent changes along different branches. Phylogenetic approaches are rarely used for functional genomics studies. 


## Results and Discussion

### KMRR Reanalysis

#### Original pairwise test of the ortholog conjecture

The KMRR study [@KryuchkovaMostacci:2016iw] sought to test the ortholog conjecture. The ortholog conjecture [@Nehrt:2011bm] is the proposition that orthologs (genes that diverged from each other due to a speciation event) have more similar attributes than do paralogs (genes that diverged from each other due to a gene duplication event). The ortholog conjecture has important biological and technical implications. It shapes our understanding of the functional diversity of gene families. It is used to relate findings from well-studied genes to related genes that have not been investigated in detail. It can be applied to any trait of genes, from gene sequence to biochemical properties to expression. While the ortholog conjecture describes a specific pattern of functional diversity across genes, it is also articulated as a hypothesis about the process of evolution-- that there is greater evolutionary change in gene attributes following a duplication event than a speciation event. 

Despite its importance, there have been relatively few tests of the ortholog conjecture. Previous work has shown that ontology annotations are not sufficient to test the ortholog conjecture [@Chen:2012jz; @Thomas:2012hz]. Analyses of domain structure were consistent with the ortholog conjecture [@Forslund:2011cw]. There have been few tests of the ortholog conjecture with regards to gene expression [@Chen:2012jz], and KMRR is the most thorough such expression study to date.

The KMRR study considered several publicly available datasets. Here we consider their conclusions in the context of one of these studies, Brawand *et al.* 2011 [@Brawand:2011du]. This dataset of gene expression for six organs across ten species (nine mammals and one bird), eight of which were analyzed by KMRR, is the best sampled in their analyses. Their expression summary statistic is Tau [@Yanai:2005dh, @KryuchkovaMostacci:2016in], an indicator of tissue specificity of gene expression. It can range from a value of 0, which indicates no specificity (*i.e.*, uniform expression across tissues), to a value of 1, which indicates high specificity (*i.e.*, expression in only one tissue). It is convenient in that it is a single number of defined range for each gene, though of course since the original expression is multidimensional this means much information is discarded. This includes information about which tissue expression is specific to. For example, if one gene has expression specific to the brain and another expression specific to the kidney, both would have a Tau of 1. 

Results in KMRR are based on pairwise comparisons (Figure 1A) between Tau within each gene family. They found the correlation coefficient of Tau for orthologs to be significantly greater than the correlation coefficient of Tau for paralogs, *i.e.* that orthologs tend to be more similar to each other than paralogs. From this they concluded that their analyses support the ortholog conjecture. They also concluded that this pattern provides support for a particular evolutionary process, that "tissue-specificity evolves very slowly in the absence of duplication, while immediately after duplication the new gene copy differs".

#### Phylogenetic reanalyses

We reanalyzed the KMRR study using phylogenetic comparative methods, focusing on the dataset of Brawand *et al.* 2011 [@Brawand:2011du]. For each internal node in each gene tree (Figure 1b), we measured the phylogenetic independent contrast (PIC) [@Felsenstein:1985ua] of the expression statistic Tau. This is the difference in values of Tau for descendant nodes scaled by the expected variance (determined largely by the lengths of these branches). These contrasts were then annotated by whether they are made across a speciation or duplication event. The original description of independent contrasts [@Felsenstein:1985ua] focused on assessing covariance between changes in two traits on a tree. Our use of contrasts is a bit different-- we look for differences in evolutionary changes of one trait (differential expression) between two categories of nodes (speciation and duplication) on a tree.

```{r expectation_plots, echo=FALSE, cache=TRUE, message=F, warning=F}
	
	g_expectation_null =
		sim_expectation() %>%
		ggplot( aes( x=pic, y=..density.., col=Event ) ) + 
			geom_freqpoly(  binwidth=0.2, position="identity" ) +
			xlab( "Phylogenetic independent contrasts (PIC)" ) +
			ylab( "Density" ) +
			xlim( 0, 6 ) + 
			theme_classic() +
			theme( 
				axis.text.x=element_blank(), 
				axis.ticks.x=element_blank(), 
				axis.text.y=element_blank(), 
				axis.ticks.y=element_blank(),
				legend.justification=c( 1, 1 ), 
				legend.position=c( 1, 1 )
			) +
			ggtitle( "(a) Null expectation" )
	
	g_expectation_oc =
		sim_expectation( scale=2 ) %>%
		ggplot( aes( x=pic, y=..density.., col=Event ) ) + 
			geom_freqpoly(  binwidth=0.2, position="identity" ) +
			xlab( "Phylogenetic independent contrasts (PIC)" ) +
			ylab( "Density" ) +
			xlim( 0, 6 ) + 
			theme_classic() +
			theme( 
				axis.text.x=element_blank(), 
				axis.ticks.x=element_blank(), 
				axis.text.y=element_blank(), 
				axis.ticks.y=element_blank(),
				legend.position="none"
			) +
			ggtitle( "(b) Ortholog Conjecture (OC) expectation" )
	
	grid.arrange(
			g_expectation_null,
			g_expectation_oc,
			ncol = 2
		)

```

> Figure XXExpectations | (a) Under the null hypothesis that there is no difference in the rate of evolution after duplication or speciation events, the distribution of PICs would be the same across both types of nodes. (b) Under the ortholog conjecture, contrasts across duplication nodes would tend to be larger than contrasts across speciation nodes.

To test the ortholog conjecture it is essential to have a null hypothesis that makes predictions distinct from the ortholog conjecture. A suitable null hypothesis is that there is no difference in evolutionary change in differential expression along branches that descend from speciation or duplication events [@Studer:2009bm] (Figure 1b). Under this hypothesis, we would predict that contrasts across speciation nodes and duplication nodes are drawn from the same distribution (Figure XXEXPECTATIONS a). Under the alternative hypothesis specified by the ortholog conjecture, that there is a higher rate of change following duplication events than speciation events, we would expect to see the distribution of duplication contrasts shifted to higher values relative to the speciation contrasts (Figure XXEXPECTATIONS b).

```{r load_trees, echo=FALSE, cache=TRUE, message=F, warning=F}

	# Read in the tree file as a vector of strings, one per line
	lines = readLines( gene_tree_name )

	# Isolate strings that are trees
	# These start with (
	tree_lines = lines[ grepl( "^\\(", lines, perl = TRUE ) ]

	# Parse each string to a treeio::treedata object, adding a label column 
	# for node names
	gene_trees = mclapply(
		tree_lines,
		function( x ){
			tree_tc = textConnection( x )
			tree = treeio::read.nhx( tree_tc )
			close( tree_tc )
			tree@data$label = c( tree@phylo$tip.label, tree@phylo$node.label )
			return( tree )
		}, mc.cores=cores
	)
	
	# Parse the tree annotations, these are lines that start with SEQ
	# These have the species names, which are not in the trees themselves
	tip_annotations = 
		lines[ grepl( "^SEQ", lines, perl = TRUE ) ] %>%	# Get lines that start with SEQ
		str_c( collapse="\n" ) %>%												# Combine them into one string
		read_delim( delim=" ", col_names = FALSE ) %>% 		# Read string as tibble
		select( 2, 8 ) %>%																# Select the columns with species and gene ID
		rename(  Ensembl.Gene.ID = X8 ) %>%
		rename(  species = X2 )
	
```

```{r load_expression, echo=FALSE, message=F, warning=F}

	# Read the expression data for each species and combine into a single tibble,
	# adding the species names from tip_annotations
	expression = 
		lapply(
			expression_file_names, 
			read.table, 
			stringsAsFactors=FALSE, 
			header=TRUE
		) %>%
		bind_rows() %>%
		left_join( tip_annotations, by="Ensembl.Gene.ID" )

```


```{r add_expression_to_trees, echo=FALSE, cache=TRUE, message=F, warning=F}

	# Annotate each tree by joining the corresponding expression data to the 
	# @data object. This maps the expression data to the tree tips
	gene_trees_annotated = mclapply(
		gene_trees,
		function( tree ){
			tree@data %<>% left_join( expression, by = c( "G" = "Ensembl.Gene.ID" ) )
			
			tree@data$Event = NA
			tree@data$Event[ tree@data$D == "N" ] = "Speciation"
			tree@data$Event[ tree@data$D == "Y" ] = "Duplication"
			tree@data$Event = factor( tree@data$Event, levels=c( "Speciation", "Duplication" ) )
			
			return( tree )
		}, 
		mc.cores=cores
	)

	# Remove tips from the trees that do not have expression data
	gene_trees_pruned = mclapply( 
		gene_trees_annotated, 
		drop_empty_tips, 
		min_genes_with_expression=min_genes_with_expression,
		mc.cores=cores 
	)

	# Remove trees with less than min_genes_with_expression tips with expression data
	gene_trees_pruned = gene_trees_pruned[ ! is.na( gene_trees_pruned ) ]
	
	n_removed_for_no_speciation = length( gene_trees_pruned )
	
	# Remove trees with no speciation events
	gene_trees_pruned = gene_trees_pruned[  unlist( lapply( gene_trees_pruned, get_n_speciation ) ) > 0 ]
	
	n_removed_for_no_speciation = n_removed_for_no_speciation - length( gene_trees_pruned )
	
	# fix clade names
	gene_trees_pruned = lapply( gene_trees_pruned, fix_hominini )

```

```{r calibrate_trees, echo=FALSE, cache=TRUE, message=F, warning=F}

	# Time calibrate all speciation nodes to the same years
	gene_trees_calibrated = calibrate_trees( gene_trees_pruned, calibration_times, model="correlated" )
	
```

```{r trees_to_contrasts, cache=TRUE, echo=FALSE, message=F, warning=F}

	# Calculate the contrasts from the trees and associated expression data
	gene_trees_pic = add_pics_to_trees( gene_trees_calibrated )

	# Collect all the contrasts in a single tibble
	nodes_contrast = summarize_contrasts( gene_trees_pic )
	
	# Test if the mean rank of duplication pics is greater than speciation pics
	wilcox_test_result = wilcox_oc( nodes_contrast )
	
```


```{r show_contrast_result, echo=FALSE, cache=TRUE, message=F, warning=F}

	# Plot the contrasts for duplication events and speciation events
	nodes_contrast %>%
		ggplot( aes( x=pic, y=..density.., col=Event ) ) + 
		geom_freqpoly( binwidth=.001, position="identity" ) +
		xlab( "Phylogenetic independent \ncontrasts (PIC)" ) +
		ylab( "Density" ) +
		xlim( 0, 0.075 ) + 
		theme_classic()

```

> Figure XXKMRR | Density plot of the magnitude of phylogenetic independent contrast values following duplication and speciation events. These contrasts are not larger following duplication events, as predicted by the ortholog conjecture.


When we reanalyze the data with phylogenetic independent contrasts, we did not find increased evolutionary change in expression following duplication events (Fig. XXKMRR). Of the `r length(gene_trees)` trees that were parsed from ENSMBL Compara [@Herrero:2016jj], `r length(gene_trees_pruned)` passed taxon sampling criteria (`r min_genes_with_expression` genes) after removing tips without Tau values and had at least one speciation event. Of these, `r length(gene_trees_calibrated)` were successfully time calibrated. These calibrated pruned trees were used to calculate phylogenetic independent contrasts for Tau. They contain `r nodes_contrast %>% filter(D=="Y") %>% nrow()` duplication nodes and `r nodes_contrast %>% filter(D=="N") %>% nrow()` speciation nodes.

Given the ortholog conjecture, we would expect to see larger contrasts following duplication events than speciation events. Instead, we find no such distribution (Figure XXKMRR). The Wilcoxon rank test does not reject the null hypothesis that the rate of evolution following duplications is the same as or less than the rate following speciation (p value = `r wilcox_test_result`). Our results therefore find no evidence for the ortholog conjecture in this system.

```{r ascertainment, cache=TRUE, echo=FALSE, fig.cap="XX_PIC_VAR", warning=FALSE, message=FALSE}

	# Examine by node age

	g_age =
		nodes_contrast %>%
		ggplot( aes( x=node_age, y=pic, col=Event ) ) + 
			geom_point( alpha=0.2 ) + 
			xlab( "Node age (millions of years)" ) + 
			ylab( "Phylogenetic independent contrasts (PIC)\n of differential expression" ) +
			ylim( 0, 0.3 ) +
			xlim( 0, 1000 ) +
			ggtitle( "(a)" ) +
			theme_classic()	

	max_speciation_age = 
		nodes_contrast %>% 
		filter( D=="N" ) %>%
		select( node_age ) %>%
		max( na.rm=TRUE )
	
	nodes_contrast_filtered_age = 
		nodes_contrast %>% 
		filter( node_age <= max_speciation_age )
	
	wilcox_filtered_age = wilcox_oc( nodes_contrast_filtered_age )

	# Examine by expected variance, ie branch length
	var_exp_max = 
		nodes_contrast %>% 
		filter( D=="N" ) %>%
		select( var_exp ) %>%
		max( na.rm=TRUE )

	var_exp_min = 
		nodes_contrast %>% 
		filter( D=="N" ) %>%
		select( var_exp ) %>%
		min( na.rm=TRUE )

	nodes_contrast_filtered_var = 
		nodes_contrast %>% 
		filter ( ( var_exp >= var_exp_min ) & ( var_exp <= var_exp_max ) )
	
	wilcox_filtered_var = wilcox_oc( nodes_contrast_filtered_var )

	
```

We next examined the possibility that ascertainment biases were differentially impacting the inference of evolution following duplication and speciation events. We focused on two possible sources of bias - node depth and branch length. We found no evidence that either affected our results (Supplementary Materials). We also examined the sensitivity of the results to the calibration times used for speciation events on the gene trees. This is important because it is expected that genes from separate species trace backward in time to a common ancestor at older times than the splitting times of the species to which they belong [@Takahata:1989uh; @Degnan:2009hr]. There is also uncertainty associated with the timing of these speciation events. In replicate analyses we added random noise to the calibration times and found that it does not impact our inability to reject the null hypothesis (Supplementary Materials).

#### Understanding the incongruence between pairwise and phylogenetic methods

```{r pairwise, echo=FALSE, cache=TRUE, message=F, warning=F}
	get_pairwise_summary = function ( nhx ) {
		
		# Create a tibble with one row for each pairwise combination of tip nodes
		ntips = length( nhx@phylo$tip.label )
		D = 1:ntips %>% combn( 2 ) %>% t() %>% as_tibble()
		names( D ) = c( "tip_a", "tip_b" )
		
		# Add a column with the gene tree hash 
		D %<>% mutate( gene_tree = digest( nhx ) )
		
		# Add the tip names
		D %<>% mutate ( name_a = nhx@data$G[ D$tip_a ] )
		D %<>% mutate ( name_b = nhx@data$G[ D$tip_b ] )
		
		# Add the species
		D %<>% mutate ( species_a = nhx@data$species[ D$tip_a ] )
		D %<>% mutate ( species_b = nhx@data$species[ D$tip_b ] )
		
		# Add the values at the tips
		D %<>% mutate ( tau_a = nhx@data$Tau[ D$tip_a ] )
		D %<>% mutate ( tau_b = nhx@data$Tau[ D$tip_b ] )
		D %<>% mutate ( difference = abs( tau_a - tau_b ) )
		
		# For each row, get the most recent common ancestor of the pairwise tip combination
		D$mrca = 
			apply(
				D, 
				1, 
				function( y ) ape::getMRCA( 
					nhx@phylo, 
					c( as.integer( y['tip_a'] ), as.integer( y['tip_b'] ) )
				)
			) %>%
			as.integer()
		
		# Merge data of this mrca to the node
		D %<>% left_join(
			nhx@data %>%
				select( D, Event, node, node_age, label, pic ),
			by = c( "mrca" = "node")
				
		)
		
		# Calculate the distance between the tips, which for an ultrametric tree 
		# is twice the age of their most recent common ancestor
		D %<>% mutate( distance = 2 * node_age )
		
		return( D )
		
	}

	# Build a tibble of all pairwise comparisons between tips
	pairwise_summary = 
		mclapply( gene_trees_pic, get_pairwise_summary, mc.cores=cores ) %>% 
		bind_rows()
	
	# Calculate some summary statistics 
	ortholog_r = 
		pairwise_summary %>% 
		filter( D=="N" ) %>% 
		select( tau_a, tau_b ) %>% 
		cor( ) %>% 
		.[ 1, 2 ]
	
	paralog_r = 
		pairwise_summary %>% 
		filter( D=="Y" ) %>% 
		select( tau_a, tau_b ) %>% 
		cor( ) %>% 
		.[ 1, 2 ]
	
	paralog_subset_r = 
		pairwise_summary %>% 
		filter( D=="Y" ) %>% 
		filter( node_age <= max_speciation_age ) %>% 
		select( tau_a, tau_b ) %>% 
		cor( ) %>% 
		.[ 1, 2 ]
	
	ortholog_distance_mean = 
		pairwise_summary %>% 
		filter( D=="N" ) %>% 
		.[["distance"]] %>% 
		mean()
	
	paralog_distance_mean = 
		pairwise_summary %>% 
		filter( D=="Y" ) %>% 
		.[["distance"]] %>% 
		mean()
	
	pairwise_summary %>% 
		filter( species_a == "homo_sapiens" | species_b == "homo_sapiens" ) %>% 
		filter( ! is.na( D ) ) %>%
		group_by( Event, label ) %>% 
		summarise( cor.test(  tau_a, tau_b )$estimate, n=n() ) %>% 
		rename( rho=`cor.test(tau_a, tau_b)$estimate` ) %>%
		rename( clade = label ) %>% 
		left_join( calibration_times, clade=clade ) %>%
		ggplot() + 
			geom_point( aes( x=age, y=rho, col=Event, size=n ) ) +
			theme_classic()
	
```

> Figure XX_KMRR_Pairwise | This figures demonstrates that the pairwise analyses presented in Figure 2a of KMRR can be reproduced with the subset of data we consider here and our own independent code base. Each circle indicates the Tau Pearson correlation (rho) for a set of pairwise comparisons annotated with a specific node name of a given age and event type, *i.e.*, whether the divergence at that nodes was due to speciation (giving rise to orthologs) or duplication (giving rise to paralogs). Following KMRR Figure 2a, this figure shows only the comparisons that include a human sequence.

In order to better understand why our phylogenetic analysis supports a different conclusion (*i.e.*, no support for the ortholog conjecture) than the published analysis of KMRR [@KryuchkovaMostacci:2016iw] (*i.e.*, strong support for the ortholog conjecture), we first checked to make sure we could reproduce their result based on pairwise analyses. This is important since we are only looking at at a subset of the data they considered, the Brawand *et al.* 2011 [@Brawand:2011du] dataset for gene trees that could be successfully time calibrated. In their Figure 1, they present a higher Tau correlation coefficient between ortholog pairs than paralog ortholog pairs. We find the same here, with correlation coefficients of R=`r round( ortholog_r, 3)` between ortholog pairs and `r round( paralog_r, 3)` for paralog pairs. 

Why is it that pairwise methods and phylogenetic methods lead to opposite conclusions? The reason is that they describe different things. Pairwise comparisons describe contemporary patterns, while phylogenetic methods infer historical processes [@OMeara:2012gq]. There need not be a different process of evolution following speciation and duplication for paralogs to be more different than orthologs. This could be due to the structure of the gene phylogenies. If paralogs tend to be more distantly related to each other than orthologs, then there would be more time for differences to accumulate even if the rate of change is the same between the two. This is, in fact, the case for these data. While the mean distance between orthologs is `r round( ortholog_distance_mean, 1 )` My, the mean distance between paralogs is `r round( paralog_distance_mean, 1 )` My. As described above, this is because the oldest speciation event is by definition the most recent common ancestor of the species included in the study, but many gene families underwent duplication before this time.

To test the hypothesis that distantly related paralogs arising from these older duplication events (Supplementary Figure XXAscertainment a) are the reason for the lower correlation of Tau between paralogs than between orthologs, we removed them. When we consider only the paralogs that arise from duplication events the same age or younger than the oldest speciation event (Supplementary Figure XXAscertainment b), the observed pattern is very different. The correlation of Tau between these shallower paralog pairs, R=`r round( paralog_subset_r, 3)`, is much stronger than for the correlation between all paralog pairs, R=`r round( paralog_r, 3)`. This is much closer to the ortholog correlation, which has R=`r round( ortholog_r, 3) `.



```{r simulations_null, cache=TRUE, echo=FALSE, fig.cap="XX_PIC_VAR", warning=FALSE, message=FALSE}
	
	# Replace the actual Tau values with simulated Tau values, using parameters 
	# fitted from each tree
	gene_trees_sim_null = lapply( gene_trees_calibrated, sim_tau )
	
	# Perform contrasts 
	gene_trees_sim_null %<>% add_pics_to_trees()
	nodes_sim_null_contrast = gene_trees_sim_null %>% summarize_contrasts()
	
	# Calculate pairwise comparisons
	pairwise_sim_null_summary = 
		mclapply( gene_trees_sim_null, get_pairwise_summary, mc.cores=cores ) %>% 
		bind_rows()
	
	# Calculate some summary statistics 
	ortholog_r_sim_null = 
		pairwise_sim_null_summary %>% 
		filter( D=="N" ) %>% 
		select( tau_a, tau_b ) %>% 
		cor( ) %>% 
		.[ 1, 2 ]
	
	paralog_r_sim_null = 
		pairwise_sim_null_summary %>% 
		filter( D=="Y" ) %>% 
		select( tau_a, tau_b ) %>% 
		cor( ) %>% 
		.[ 1, 2 ]

```


```{r simulations_oc, cache=TRUE, echo=FALSE, fig.cap="XX_PIC_VAR", warning=FALSE, message=FALSE}

	# Replace the actual Tau values with simulated Tau values, using parameters 
	# fitted from each tree. 
	gene_trees_sim_oc = lapply( gene_trees_calibrated, sim_tau, dup_adjust=dup_adjust )
	
	# Calculate contrasts 
	gene_trees_sim_oc %<>% add_pics_to_trees()
	nodes_sim_oc_contrast = gene_trees_sim_oc %>% summarize_contrasts()
	
	# Calculate pairwise comparisons 
	pairwise_sim_oc_summary = 
		mclapply( gene_trees_sim_oc, get_pairwise_summary, mc.cores=cores ) %>% 
		bind_rows()
	
	ortholog_r_sim_oc = 
		pairwise_sim_oc_summary %>% 
		filter( D=="N" ) %>% 
		select( tau_a, tau_b ) %>% 
		cor( ) %>% 
		.[ 1, 2 ]
	
	paralog_r_sim_oc = 
		pairwise_sim_oc_summary %>% 
		filter( D=="Y" ) %>% 
		select( tau_a, tau_b ) %>% 
		cor( ) %>% 
		.[ 1, 2 ]
	
```


```{r simulations_plot, cache=TRUE, echo=FALSE, fig.cap="XX_PIC_VAR", warning=FALSE, message=FALSE}

	g_phylo_null = 
		nodes_sim_null_contrast %>% 
		ggplot( aes( x=pic, y=..density.., col=Event ) ) + 
			geom_freqpoly( binwidth=.0025, position="identity" ) +
			xlab( "Phylogenetic Independent Contrast" ) +
			ylab( "Density" ) +
			xlim( 0, 0.05 ) + 
			ylim( 0, 75 ) +
			theme_classic() + 
			ggtitle( "(b) Null simulation, phylogenetic" ) +
			theme( legend.justification=c( 1, 1 ), legend.position=c( 1, 1 ) )

	g_pair_null = 
		pairwise_sim_null_summary %>% 
		filter( species_a == "homo_sapiens" | species_b == "homo_sapiens" ) %>% 
		filter( ! is.na( D ) ) %>%
		group_by( Event, label ) %>% 
		summarise( cor.test(  tau_a, tau_b )$estimate, n=n() ) %>% 
		rename( rho=`cor.test(tau_a, tau_b)$estimate` ) %>%
		rename( clade = label ) %>% 
		left_join( calibration_times, clade=clade ) %>%
		ggplot() + 
			geom_point( aes( x=age, y=rho, col=Event, size=n ) ) +
			theme_classic() +
			xlab( "Age" ) +
			ylab( "Rho" ) +
			ylim( 0, 1 ) +
			ggtitle( "(a) Null simulation, pairwise" ) +
			theme(legend.position="none")

	g_phylo_oc = 
	nodes_sim_oc_contrast %>% 
	ggplot( aes( x=pic, y=..density.., col=Event ) ) + 
		geom_freqpoly( binwidth=.0025, position="identity" ) +
		xlab( "Phylogenetic Independent Contrast" ) +
		ylab( "Density" ) +
		xlim( 0, 0.05 ) + 
		ylim( 0, 75 ) +
		theme_classic() + 
		ggtitle( "(d) OC simulation, phylogenetic" ) +
		theme(legend.position="none")

	g_pair_oc = 
		pairwise_sim_oc_summary %>% 
		filter( species_a == "homo_sapiens" | species_b == "homo_sapiens" ) %>% 
		filter( ! is.na( D ) ) %>%
		group_by( Event, label ) %>% 
		summarise( cor.test(  tau_a, tau_b )$estimate, n=n() ) %>% 
		rename( rho=`cor.test(tau_a, tau_b)$estimate` ) %>%
		rename( clade = label ) %>% 
		left_join( calibration_times, clade=clade ) %>%
		ggplot() + 
			geom_point( aes( x=age, y=rho, col=Event, size=n ) ) +
			theme_classic() +
			xlab( "Age" ) +
			ylab( "Rho" ) +
			ylim( 0, 1 ) +
			ggtitle( "(c) OC simulation, pairwise" ) +
			theme(legend.position="none")

	grid.arrange(
		g_pair_null,
		g_phylo_null,
		g_pair_oc,
		g_phylo_oc,
		ncol = 2
	)


```

> Figure XXSim

We simulated a data set under the null model that tau evolves at the same rate following duplication and speciation events. Under the null model, pairwise analysis results (Figure XXSim a) are very similar as for the observed data, with higher rho for orthologs (`r ortholog_r_sim_null`) than paralogs (`r paralog_r_sim_null`). In the phylogenetic analysis of the null simulation, contrasts show similar divergence following speciation and duplication (Figure XXSim b) and does not reject the null hypothesis (Wilcoxon p=`r wilcox_oc( nodes_sim_null_contrast )`).

We next simulated a data set under the ortholog conjecture, where the rate of evolution of Tau following duplication was `r dup_adjust` fold the rate following speciation. The results of this heterogeneous model are nearly indistinguishable from the null model  (Figure XXSim c), and also have a higher rho for orthologs (`r ortholog_r_sim_oc`) than paralogs (`r paralog_r_sim_oc`). In the phylogenetic analysis of the ortholog conjecture simulation, contrasts XX (Figure XXSim c) and XX (Wilcoxon p=`r wilcox_oc( nodes_sim_oc_contrast )`).

#### Implications for the ortholog conjecture

We find that having information on whether two genes are orthologs or paralogs provides little added information about expression beyond knowing how distantly related the two genes are. This has several implications. It is an example of the limitations of the concepts of orthology and paralogy [@Dunn:2016er]. These terms can have straightforward meaning in small gene trees with simple duplication/speciation histories, but the utility of the terms breaks down on larger more complex gene trees. Orthology and paralogy are annotations on the tips of the tree that are derived from the inferred structure of the tree and history of duplication and speciation at internal tree nodes. In this sense, orthology and paralogy are statements about the internals of the tree that are distilled into statements at the tips of the tree. Much is lost in the process, though. These are the same pre-computed trees we use in our phylogenetic re-analyses of their study. For most questions it is much more direct to focus on the structure of the tree and the inferred processes within the tree, such as which internal nodes are duplication or speciation events and how much change occurs along the branches. In this case, KMRR [@KryuchkovaMostacci:2016iw] relied on orthology and paralogy annotations that are derived from the inferred duplication and speciation history on gene phylogenies [@Herrero:2016jj]. 

There has been considerable recent interest in, and controversy about, the ortholog conjecture [@Koonin:2005fp; @Studer:2009bm; @Nehrt:2011bm; @Gabaldon:2013fi]. Our results are consistent with multiple studies that have not found support for the ortholog conjecture [@Studer:2009bm; @Nehrt:2011bm; @Yanai:2004hk]. Another study found only slightly greater similarity between orthologs than paralogs [@Altenhoff:2012ea].

Our reanalysis of KMRR using phylogenetic methods suggests that the ortholog conjecture is not a dominant pattern that is central to explaining the evolution of phenotypic diversity in gene families. This has important biological implications. It suggests that the mechanism of gene divergence (speciation versus duplication) may not have as strong an impact on phenotypic divergence as sometimes proposed. It also has technical implications. Rather than focus on whether genes are orthologs or paralogs when attempting to predict function, it may be more effective to simply focus on how closely related or distantly related they are. Closely related paralogs, for example, may tend to have more similar phenotypes than more distantly related orthologs [@Studer:2009bm]. 

The ortholog conjecture does not have to be an all or nothing question. It may be the case that the rates of phenotypic evolution following duplication may be greater than that following duplication in some organisms, gene families, and evolutionary processes [@Gabaldon:2013fi]. We just don't find evidence for it when summarizing gene expression across tissues with Tau in these mammals. This calls into question the general predictive power of the ortholog conjecture, and until these processes are better understood it will be necessary to test for it in each situation. These tests should be articulated in terms of clear alternative hypotheses [@Studer:2009bm] that make distinct phylogenetic comparative predictions.

### Levin *et al.* reanalysis

#### Original pairwise analyses of developmental gene expression

![Figure Levin](levin_etal/Figure_levin.png?raw=true)

> Figure XXLevin | Distributions of pairwise similarity scores for each phase of development. Pairwise scores for the ctenophore are red. Wilcoxon test p-values for the significance of the differences between early-mid distributions and late-mid distributions are on the right. Model of variance, which is inversely related to similarity, is on the left. (a) The distributions as published. Low similarity (*i.e.*, high variance) in the mid phase of development was interpreted as support for an inverse hourglass model for the evolution of gene expression. The five least-similar mid phase scores were all from the ctenophore. Published KS p-values, based on duplicated data, are in parentheses. The inset ctenophore image is by S. Haddock from phylopic.org. (b) The distributions after the exclusion of the ctenophore. The early and mid phase distributions are not statistically distinct. This suggest a wine bottle model, with similar evolutionary variance at the early and mid phase and less at the late phase.

How changes in animal development relate to the evolution of animal diversity is a major question in evolutionary developmental biology (EvoDevo). To address this topic, Levin *et al.* [@Levin:2016bp] analyzed gene expression through the course of embryonic development for ten animal species, each from a different phylum. They arrived at two major conclusions. First, animal development is characterized by a well-defined mid-developmental transition that marks the transition from an early phase of gene expression to a late stage of gene expression. Second, this transition helps explain the evolution of features observed among distantly related animals. Specifically, they concluded that animals from different phyla exhibit an "inverse hourglass" model for the evolution of gene expression, where there is more evolutionary variance in gene expression at a mid phase of development than there is at early and late phases. Closely related animals have previously been described as having an hourglass model of gene expression, where evolutionary variance in expression is greater early and late in development than at the midpoint of development [@Kalinka:2010dw; @DomazetLoso:2010cn]. Levin *et al.* conclude that this contrast between distantly and closely related animals provides biological justification for the concept of phyla and may provide a definition of phyla. 

Levin *et al.* [@Levin:2016bp] arrived at this conclusion by making multiple pairwise comparisons of ortholog expression through development between each pair of species. For each species pair, they identified the orthologs shared by these species. This list of shared genes was different from species pair to species pair. They characterized each gene in each species as having expression that peaks in early, mid, or late temporal phase of development. They then calculated a similarity score for each temporal phase for each species pair based on the fraction of genes that exhibited the same patterns in each species. The distributions of similarity scores are plotted in their [Figure 4d](http://www.nature.com/nature/journal/v531/n7596/fig_tab/nature16994_F4.html), and their Kolmogorov–Smirnov (KS) tests indicated that the early distribution and late distribution were each significantly different from mid distribution (P < 10<sup>-6</sup> and P < 10<sup>-12</sup>, respectively). This is the support they presented for the inverse hourglass model.


#### Reexamination of pairwise comparisons

We examined the matrix of pairwise comparisons used as the base for the KS tests and Figure 4d in *Levin et al.* [@Levin:2016bp], and thus as evidence to support the "inverse hourglass model". We found several problems resulting from the use of multiple pairwise comparisons. First, we found that every data point was included twice because both reciprocal pairwise comparisons (which have the same values) were retained. For example, there is both a nematode to arthropod comparison and an arthropod to nematode comparison. As a consequence, there are 90 entries for the 45 pairwise comparisons, and by doubling the data the significance of the result appears stronger than it actually is. After removing the duplicate values, the p values are far less significant, 0.002 for the early-mid comparison and on the order of 10<sup>-6</sup> for early-late. In addition, the test they used (KS test) is not appropriate for the hypothesis they seek to evaluate. The KS test does not just evaluate whether one distribution is greater than the other, it also tests whether the shape of the distributions are the same. In addition, the samples in this dataset are matched (*i.e.*, for each pairwise comparison there is a early, mid, and late expression value), which the KS test does not take into account. The Wilcoxon test is instead appropriate in this case. When applied to the de-duplicated data, the significance of this test is 0.02 for the early-mid comparison and on the order of 10<sup>-7</sup> for early-late.

The next issue we found was that all five of the lowest values in the mid phase distribution (Figure XXLevin a) are for pairwise comparisons that include the ctenophore (comb jelly). When the nine pairwise comparisons that include the ctenophore are removed and the general statistical issues noted above are addressed, there is no significant difference between the early phase and mid phase distributions (P = 0.1428 for the early-mid comparison and P < 10<sup>-5</sup> for the late-mid comparison). The inverse hourglass turns into a bottle (Figure XXLevin b). This highlights a well understood property of pairwise comparisons across species [@Felsenstein:1985ua]: evolutionary changes along a given branch, like those along the ctenophore branch, impact each of the multiple pairwise comparisons that includes that branch. The pairwise comparisons are therefore not independent - different pairwise comparisons are impacted by canges along some of the same branches (Figure 1a). This can give the impression of a general pattern across the tree that is instead specific to changes along one part of the tree. The number of comparisons impacted by each change depends on the structure of the phylogenetic tree, i.e. how the species are related to each other.

Phylogenetic comparative methods were developed specifically to address this problem [@Felsenstein:1985ua]. While we do demonstrate this problem impacts the Levin et al. analysis, we did not perform a phylogenetic reanalysis of this study, as we did for the KMRR study. This is because the similarity metric computed in the pairwise comparisons of Levin et al. are based on different genes for different species pairs. This means that they do not generate a trait that can be evaluated across a phylogeny, as KMRR's Tau can be. A full phylogenetic reanalysis would be possible by using upstream analysis products to re-derive new expression summary statistics suitable for phylogenetic comparative methods.


### Phylogenetic comparative methods in functional genomics

Our results highlight the importance of explicitly accounting for phylogenetic relationships when studying character evolution, including developmental [@Telford:2003tsa] and functional genomic traits [@Hejnol:2015gr]. This is particularly true for evolutionary analyses of quantitative gene expression [@Dunn:2013cpa]. 

Some of the most widely used phylogenetic comparative methods [@Felsenstein:1985ua; @Grafen:1989um] are already directly applicable to CFG data. There are interesting new challenges at this interdisciplinary interface that will need to be addressed to fully realize the potential of phylogenetic comparative functional genomics studies. One such challenge is that most phylogenetic comparative analyses of covariance between traits have been developed to address problems with many more species (e.g., dozens or more) relative to the number of traits being examined. In CFG analyses, there are often far fewer species because adding taxa is still expensive, but tens of thousands of traits. This creates statistical challenges as the resulting covariance matrices are singular and, if not treated appropriately, imply many false correlations that are artifacts of project design. We outlined these challenges and potential solutions in the context of gene expression [@Dunn:2013cpa]. In addition to methods development, there is a critical need for software tools that make it simpler to integrate existing functional genomic and phylogenetic comparative packages.

Recent advances in phylogenetic comparative methods are particularly well suited to addressing questions about the evolution of functional genomic traits. Most early phylogenetic comparative methods attempted to account for evolutionary signal to correct statistical tests for correlations between traits, while more recent methods tend to focus on testing hypotheses of evolutionary processes [@Pennell:2013cw]. The application of this newer focus to functional genomics provides an exciting opportunity to address long standing questions of broad interest, including the order of changes in functional genomics traits and shifts in rates of evolution of one functional genomics trait following changes in another trait. 

We are not the first to apply phylogenetic comparative methods to functional genomic data. While the vast majority of comparative functional genomics studies have used standard pairwise similarity methods, a small number of CFG studies have employed phylogenetic comparative approaches [@Oakley:2005ky; @Eng:2009gp; @Chang:2014hq]. For instance, a phylogenetic ANOVA [@Rohlfs:2015bd] of the evolution of gene expression improves statistical power and drastically reduces the rate of false positives relative to pairwise approaches. 

Addressing the statistical dependence of pairwise comparisons is not the only advantage of using phylogenetic comparative methods for functional genomics analyses. Another problem with the pairwise comparisons is that, except at the tips, they summarize changes along many branches in the phylogeny. Two paralogs that diverged from a duplication event deep in the tree may have many subsequent duplication and speciation events, and changes along all these branches will impact the final pairwise comparison. Phylogenetic methods have the advantage of isolating the changes under consideration (Fig. 1b). The phylogenetic methods avoid diluting the change that occurs along the branches that follow the node in question with changes along all subsequent branches. There may still be missing speciation events, due to extinction and incomplete taxon sampling, and missing duplication events, due to gene loss, but these omissions affect both methods.

## Conclusions

The fact that the first two comparative functional genomics studies we reanalyzed show serious problems with pairwise comparisons indicates that there likely to be similar problems in other studies that use these methods, and that future comparative studies will be compromised if they continue to use pairwise methods. Studies of evolutionary functional genomics should not be focused on the tips of the tree, they should explicitly delve into the tree itself.

These analyses illustrate how important it is to not conflate evolutionary patterns with the processes that generated them. Finding a pattern wherein paralogs tend to be more different than orthologs is not evidence that there are different processes by which orthologs and paralogs evolve. This is also the expected pattern when they evolve under the same process but paralogs tend to be more distantly related to each other than orthologs are. The fact that multiple pairwise comparisons of developmental gene expression across diverse species share a particular pattern is not evidence of a general process that explains the differences between all species in the analysis. It is also the expected pattern when there are unique changes specific to a single species, as these changes will impact all pairwise comparisons to that species and therefore be counted multiple times. To use patterns across living species to test hypotheses about evolutionary processes, it is also necessary to incorporate information about evolutionary relationships, *i.e.* phylogenies. There have been decades of work on building comparative phylogenetic methods that do exactly that, and they are just as relevant to comparing functional genomics traits across species as they are to comparing morphology or any of the other traits they are already routinely applied to.



## Methods

All files needed to re-execute the analyses presented in this document are available at https://github.com/caseywdunn/comparative_expression_2017. The most recent commit at the time of the analysis presented here was `r system("git log | head -n 1", intern=TRUE) %>% str_replace("commit ", "")`. See the `readme.md` file in this repository for more information on the contents of the source file and how to re-execute them.


### KMRR reanalysis

The KMRR study [@KryuchkovaMostacci:2016iw] followed excellent practices in reproducibility. They posted all data and code needed to re-execute their analyses at figshare: https://figshare.com/articles/Tissue-specificity_of_gene_expression_diverges_slowly_between_orthologs_and_rapidly_between_paralogs/3493010/2 . We slightly altered their `Rscript.R` to simplify file paths and specify one missing variable. This modified script and their data files are available in the github repository for this paper, as are the intermediate files that were generated by their analysis script that we used in our own analyses. We also obtained the `Compara.75.protein.nh.emf` gene trees [@Herrero:2016jj] from ftp://ftp.ensembl.org/pub/release-75/emf/ensembl-compara/homologies/ and place them in the same directory as this file. These gene trees include branch lengths and annotate each internal node as being a duplication or speciation event.

We considered only the data from Brawand *et al.* 2011 [@Brawand:2011du] for the eight taxa included in KMRR. We left in sex chromosome genes and testes expression data, which KMRR removed in some of their sensitivity analyses. This corresponded to the analyses that provided the strongest support for the ortholog conjecture and therefore the most conservative reconsideration of it.

After parsing the trees from the Compara file with treeio, which was recently split from ggtree [@Yu:2016fo], we added Tau estimates generated by the KMRR `Rscript.R` to the tree data objects. We then pruned away tips without expression data, retaining only the trees with `r min_genes_with_expression` or more tips. We also only retained trees with one or more speciation events, as speciation events are required for calibration steps. This removes trees that have multiple genes from only one species after pruning away tips without expression data.

The gene trees were then time calibrated. The goal is not necessarily to have precise dates for each node, but to scale branch lengths so that they are equivalent across the trees. This in turn scales the phylogenetic independent contrasts (which take branch length into account) so they can be compared appropriately. We found a problem with the clade names on the ENSEMBL Compara trees, which others have also identified [@Daub:2016gd], that first had to be fixed. Hominini is the name for the clade that includes humans and chimps, while Homininae is the clade that includes humans, chimps, and gorillas. Both clades are labeled as Homininae in the Compara trees, though, which would interfere with calibration of these nodes. To fix the problem, we identified all clades labeled Homininae that have no gorilla sequence and renamed them Hominini. We then calibrated the trees by fixing the speciation nodes to the dates specified in the KMRR code, with the exception of Hominini and Homininae. These we set to 7 million years and 9 million years, drawing on the same TimeTree source [@Hedges:2006jv] that KMRR used. We used the `chronos()` function from the R package ape [@Paradis:2004dv] for this calibration, with the `correlated` model. See Supplementary Materials for additional sensitivity analyses to time calibration. Some trees could not be calibrated with these hard node constraints, and were discarded.

For each node in the remaining calibrated trees, we calculated the phylogenetic independent contrast for Tau across its daughter branches with the `pic()` function in ape [@Paradis:2004dv]. We then collected the contrasts from all trees into a single table, along with otherr annotations including whether the node is a speciation or duplication event. This table, `nodes_contrast`, was then analyzed as described in the main text for the presented plots and tests. 

### Levin et al. reanalysis

Levin *et al.* helpfully provided data and clarification on methods. We obtained the matrix of pairwise scores that underlies their [Figure 4d](http://www.nature.com/nature/journal/v531/n7596/fig_tab/nature16994_F4.html) and confirmed we could reproduce their published results. We then removed duplicate rows, applied the Wilcoxon test in place of the Kolmogorov-Smirnov test, and identified ctenophores as overrepresented among the low outliers in the mid-developmental transition column. An annotated explanation of these analyses is included in the git repository at 

## Acknowledgments

Thanks to XX. This work was supported by the National Science Foundation (DEB-1256695 and the Waterman Award).


## Supplementary Material

### KMRR Analyses


#### Summary statistics

```{r contrast_table, cache=TRUE, echo=FALSE, fig.cap="XX_PIC_VAR", warning=FALSE, message=FALSE}

clades_table = 
	nodes_contrast %>% 
	filter(D=="N") %>% 
	.$label %>% 
	table() %>% 
	as.data.frame()

names( clades_table ) = c( "Clade", "N" )

clades_table %<>%  slice( match( calibration_times$clade, Clade) )

knitr::kable(
  clades_table,
  caption = "Supplementary Table 1. Number of speciation nodes with contrasts for each clade on the tree."
)
```

```{r species_table, cache=TRUE, echo=FALSE, fig.cap="XX_PIC_VAR", warning=FALSE, message=FALSE}

	nodes_all = 
			lapply( 
				gene_trees_pic, 
				function( nhx ){
					tags = nhx@data
					tags$gene = digest( nhx ) # Creates a  hash that is unique to each gene tree
					tags %<>% select( -( B ) ) # B has inconsistent types, remove it
					return( tags )
				}
			) %>%
			bind_rows() %>%
			mutate( pic = abs( pic ) )

	
	species_table = 
		nodes_all %>% 
		filter( ! is.na( species ) ) %>% 
		.$species %>% 
		table() %>% 
		as.data.frame()

	names( species_table ) = c( "Species", "N" )
	
	species_table %<>% 
		arrange( Species ) %>%
		#mutate( Species = str_to_title( Species ) ) %>%
		mutate( Species = str_replace( Species, "_", " ") )
	
	knitr::kable(
	  species_table,
	  caption = "Supplementary Table 2. Number of tips for each species in trees that were used to calculate the independent contrasts."
	)


```

```{r example_trees, cache=TRUE, echo=FALSE, fig.cap="XX_PIC_VAR", warning=FALSE, message=FALSE}

	ntips = lapply( gene_trees_pic, function(x) length( x@phylo$tip.label ))
	to_show = which( ntips < 20 & ntips >15 )[1:8]
	
	example_trees = lapply( 
		to_show,
		function( x ){
				nhx = gene_trees_pic[[x]]
				nhx@data %<>% mutate( clade_name=label )
				nhx@data$clade_name[ is.tip.nhx(nhx) | nhx@data$D !="N" ] = NA
				
				nhx %>% 
					ggtree() + 
					geom_tiplab( aes( label=species ), hjust=-0.1 ) + 
					xlim( NA, 1400 ) + 
					geom_tippoint( aes( size=Tau ) ) +
					geom_nodepoint( aes( color=Event ), shape=15, size = 2 ) +
					geom_tippoint( aes( size=Tau ) ) +
					geom_text( aes( label=round( abs( pic ), 3 ) ), vjust=1.5, hjust=1, size=2.5, col="blue" ) + 
					geom_text( aes( label=clade_name ), vjust=-.5, hjust=1, size=2.5, col="black" ) + 
					theme( legend.position="right" )
			}
		)
	
	print( example_trees )
```

> Supplementary Figure XX_EXAMPLE_TREES | A set of example trees to demonstrate the data and analyses that underlie the results. The value of Tau (expression specificity) is indicated by the sizes of the circles at the tips of the tree. Whether an internal node is a speciation or duplication is indicated by color. Speciation nodes are labeled by clade name. Branch lengths are scaled to time. The blue number is the independent contrast for each node.


#### Investigation of potential ascertainment bias

While the age of speciation nodes is constrained, duplication nodes can be much older and therefore have a wider range of ages (Supplementary Figure XXAscertainment a). This is because many gene duplication events are older than the most recent common ancestor of the species in the study. There are also technical factors that can lead to an excess of duplication events deeper in the tree. Gene tree estimation errors errors, for example, tend to lead to the overestimation of deep duplications [@Hahn:2007cj]. If independent contrast values also tended to to be lower at greater node depth, it could interact with the preponderance of duplications at greater depth to create a pattern of lower contrasts associated with duplication events. To test for such an effect, we remove duplication nodes that are older than the oldest speciation node. Our results are unchanged and this reduced dataset does not reject the null hypothesis that the rate of evolution following duplications is the same as or less than the rate following speciation (Supplementary Figure XXAscertainment b).

The independent contrast across a node is the amount of change observed between the daughter notes, scaled by the expected variance [@Felsenstein:1985ua]. The expected variance is principally determined by the lengths of the branches leading from the node to these daughters. The shorter the total length of the two branches leading to daughter nodes, the larger the contrast for a given observed difference. This is because the same difference across a shorter total branch length indicates a greater rate of evolutionary change. The expected variance of contrasts for speciation nodes is constrained by the branch lengths on the species tree, but the expected variance of contrasts for duplications has a much wider range (Figure XXAscertainment c). This could lead to biases if the lengths of branches that descend from duplication nodes tend to be overestimated. We therefore examined only the contrasts that fell within in the range of expected variance seen for speciation contrasts, excluding duplication contrasts that fall outside of this range. This reanalysis does not reject the null hypothesis either (Figure XXAscertainment d), indicating that branch length bias is not responsible for the result.

```{r ascertainment_plot, cache=TRUE, echo=FALSE, fig.cap="XX_PIC_VAR", warning=FALSE, message=FALSE}

	# Plot results of the ascertainment bias analyses

	label_age = str_c( "Wilcoxon p=", wilcox_filtered_age )
	
	g_density_filtered_age =
		nodes_contrast_filtered_age %>%
		ggplot( aes( x=pic, y=..density.., col=Event ) ) + 
		geom_freqpoly( binwidth=.001, position="identity" ) +
		xlab( "Phylogenetic independent \ncontrasts (PIC)" ) +
		ylab( "Density" ) +
		xlim( 0, 0.075 ) + 
		ggtitle( "(b)" ) +
		annotate( "text", x = Inf, y = Inf, hjust="right", vjust="top", label=label_age ) +
		theme_classic()


	# Examine by expected variance (branch length)
	g_var_exp =
		nodes_contrast %>%
		ggplot( aes( x=var_exp, y=pic, col=Event ) ) + 
		geom_point( alpha=0.2 ) + 
		xlab( "Expected variance, \n depends mostly on branch length" ) + 
		ylab( "Phylogenetic independent contrasts (PIC)\n of differential expression" ) +
		ylim( 0, 0.3 ) +
		xlim( 0, 2000 ) +
		ggtitle( "(c)" ) +
		theme_classic()	

	label_var = str_c( "Wilcoxon p=", wilcox_filtered_var )
	
	g_density_filtered_var =
		nodes_contrast_filtered_var %>% 
		ggplot( aes( x=pic, y=..density.., col=Event ) ) + 
		geom_freqpoly( binwidth=.001, position="identity" ) + 
		ggtitle( "(d)" ) +
		theme( legend.justification=c( 1, 1 ), legend.position=c( 1, 1 ) ) +
		xlim( 0, 0.075 ) + 
		theme_classic() +
		annotate( "text", x = Inf, y = Inf, hjust="right", vjust="top", label=label_var ) +
		xlab( "Phylogenetic independent contrasts (PIC)\n of differential expression" ) +
		ylab( "Density" )

	grid.arrange(
		g_age,
		g_density_filtered_age,
		g_var_exp,
		g_density_filtered_var,
		ncol = 2
	)
```

> Supplementary Figure XXAscertainment | Investigation of possible ascertainment biases. (a) Magnitude of independent contrasts plotted against node age. Speciation nodes are calibrated to particular times, whereas duplication nodes have a wider range. (b) Density plot of contrasts for only the nodes that have an age less than or equal to the maximum age of speciation nodes. (c) Magnitude of independent contrasts plotted against expected variance, which is largely determined by branch lengths. Contrasts for speciation nodes have a narrower range of expected variance than do contrasts for duplication nodes. (d) Density plot of contrasts for only the nodes that have expected variance within the range of contrasts across speciation nodes.


#### Investigation of sensitivity to calibration times

```{r calibration_sensitivity, cache=TRUE, echo=FALSE, fig.cap="XX_PIC_VAR", warning=FALSE, message=FALSE}

	noised_replicate_n = 10
	sd_fraction = 0.2
	
	calibration_times_focal = 
		calibration_times %>%
		filter( clade %in% focal_calibrations_clades ) %>%
		arrange( age )
	
	noised_dates = 
		replicate( 
			noised_replicate_n, 
			add_noise_calibration_times( calibration_times_focal, sd_fraction ),
			simplify = FALSE
		)

	nodes_contrast_noised_list = lapply(
		noised_dates,
		function( x ){
			gene_trees_pruned %>% 
				calibrate_trees( x, model="correlated" ) %>% 
				add_pics_to_trees() %>% 
				summarize_contrasts()
		}
	)
	
	p_noised = lapply( nodes_contrast_noised_list, wilcox_oc )


```

We examined the sensitivity of our results to the specification of calibration dates for the speciation nodes. In `r noised_replicate_n` reanalyses, we drew a new date for each calibration from a normal distribution with the mean of the original date and a standard deviation `r sd_fraction` times the original date. If any daugter nodes became older than their parent, we repeated the sampling until the dates were congruent with the topology. The minimum Wilcoxon p in these reanalyses was `r min( as.numeric( unlist( p_noised ) ) )`, *i.e.* none of them reject the null hypothesis that the rate of evolution of Tau is greater following duplication events than speciation events. This is consistent with the analysis that uses the calibration dates as specified, indicating that our results are robust to the selection of calibration times for speciation nodes.


### Software versions

This manuscript was computed on `r format( Sys.time(), "%a %b %d %X %Y" )` with the following R package versions.

```{r session_summary, echo=FALSE, comment=NA}
	sessionInfo()
```


## References
